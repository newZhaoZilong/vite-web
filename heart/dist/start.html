<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>星海情书</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050515; }
        #canvas-container { width: 100vw; height: 100vh; }
        #message {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; font-family: "Microsoft YaHei", sans-serif;
            text-align: center; cursor: pointer; user-select: none;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7); z-index: 10;
        }
        #message:hover { color: #ffe0b2; text-shadow: 0 0 15px rgba(255, 255, 255, 1); }
    </style>
</head>

<body>
    <div id="canvas-container"></div>
    <div id="message">点击这里，开启星辰物语 ✨</div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "@tweenjs/tween.js": "https://unpkg.com/@tweenjs/tween.js@23.1.1/dist/tween.esm.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as TWEEN from '@tweenjs/tween.js';

        // --- 参数配置 ---
        const urlParams = new URLSearchParams(window.location.search);
        const messageText = urlParams.get('text') || "我喜欢你";
        const particleCount = 20000;

        let scene, camera, renderer, particles;
        let isAnimated = false;
        
        // 核心数据存储优化：使用 Float32Array 提升性能
        const originalPositions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3);

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 兼顾画质与性能
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 1. 初始化随机星海位置
            const starPositions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const x = Math.random() * 600 - 300;
                const y = Math.random() * 600 - 300;
                const z = Math.random() * 600 - 300;
                
                // 存入当前几何体
                starPositions[i * 3] = x;
                starPositions[i * 3 + 1] = y;
                starPositions[i * 3 + 2] = z;
                
                // 备份初始位置
                originalPositions[i * 3] = x;
                originalPositions[i * 3 + 1] = y;
                originalPositions[i * 3 + 2] = z;
            }

            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));

            const starMaterial = new THREE.PointsMaterial({
                color: 0xffe0b2,
                size: 0.8,
                transparent: true,
                blending: THREE.AdditiveBlending,
                sizeAttenuation: true
            });

            particles = new THREE.Points(starGeometry, starMaterial);
            scene.add(particles);

            // 2. 预计算文字粒子目标位置 (Canvas 采样)
            calculateTextTarget();

            // 3. 事件监听
            document.getElementById('message').addEventListener('click', startAnimation);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function calculateTextTarget() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 400;
            canvas.height = 100;

            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px "Microsoft YaHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(messageText, 200, 50);

            const imgData = ctx.getImageData(0, 0, 400, 100).data;
            const textPoints = [];

            // 采样逻辑保留，视觉效果不变
            for (let y = 0; y < 100; y += 3) {
                for (let x = 0; x < 400; x += 3) {
                    const alpha = imgData[(y * 400 + x) * 4 + 3];
                    if (alpha > 128) {
                        textPoints.push({ x: x - 200, y: (100 - y) - 50, z: 0 });
                    }
                }
            }

            // 分配粒子目标
            for (let i = 0; i < particleCount; i++) {
                const target = i < textPoints.length ? textPoints[i] : {
                    x: originalPositions[i * 3],
                    y: originalPositions[i * 3 + 1],
                    z: originalPositions[i * 3 + 2]
                };
                targetPositions[i * 3] = target.x;
                targetPositions[i * 3 + 1] = target.y;
                targetPositions[i * 3 + 2] = target.z;
            }
        }

        function startAnimation() {
            if (isAnimated) return;
            isAnimated = true;
            document.getElementById('message').style.display = 'none';

            const posAttr = particles.geometry.attributes.position;
            
            for (let i = 0; i < particleCount; i++) {
                // 为每个粒子创建 Tween
                const current = { 
                    x: posAttr.getX(i), 
                    y: posAttr.getY(i), 
                    z: posAttr.getZ(i) 
                };

                new TWEEN.Tween(current)
                    .to({ 
                        x: targetPositions[i * 3], 
                        y: targetPositions[i * 3 + 1], 
                        z: targetPositions[i * 3 + 2] 
                    }, Math.random() * 2000 + 1500)
                    .easing(TWEEN.Easing.Exponential.InOut)
                    .onUpdate(() => {
                        posAttr.setXYZ(i, current.x, current.y, current.z);
                        posAttr.needsUpdate = true;
                    })
                    .delay(Math.random() * 500)
                    .start();
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            
            // 保留原有的星海旋转视觉
            particles.rotation.y += 0.0005;
            particles.rotation.x += 0.0002;
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init(); 
    </script>
</body>
</html>