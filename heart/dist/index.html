<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>完美均匀红色渐变爱心</title>
    <style>
        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: #000;
        }
        canvas { display: block; touch-action: none; }
        #name-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff; 
            font-family: "Microsoft YaHei", "SimHei", sans-serif;
            font-size: 8vw;
            font-weight: bold;
            /* 修改：文字光晕改为红橙色系，配合爱心 */
            text-shadow: 0 0 15px rgba(255, 80, 80, 0.9), 0 0 30px rgba(200, 0, 0, 0.7);
            pointer-events: none;
            user-select: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="name-container">丫头</div>
    <canvas id="heart"></canvas>

    <script>
        const urlParams = new URLSearchParams(window.location.search);
        const nameParam = urlParams.get('name');
        if (nameParam) {
            document.getElementById('name-container').innerText = decodeURIComponent(nameParam);
        }

        setTimeout(() => {
            const canvas = document.getElementById('heart');
            const ctx = canvas.getContext('2d');

            let width, height;
            let particles = [];
            const particleCount = 3000; 
            let heartRadius;

            function resize() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
                heartRadius = width * 0.3; 
            }
            window.addEventListener('resize', resize);
            resize();

            // 隐式方程判定函数（保持不变，确保均匀）
            function isInsideHeart(x, y) {
                y = y * 1.2; 
                const a = x * x + y * y - 1;
                return Math.pow(a, 3) - x * x * Math.pow(y, 3) <= 0;
            }

            class Particle {
                constructor() {
                    this.init(true);
                }

                init(firstTime = false) {
                    this.updateTarget();
                    
                    if (firstTime) {
                        this.x = Math.random() * width;
                        this.y = Math.random() * height;
                    } else {
                        this.x = width / 2;
                        this.y = height / 2;
                    }
                    
                    this.size = Math.random() * 1.5 + 0.5;
                    this.speed = Math.random() * 0.03 + 0.01;
                    
                    // 计算距离中心的程度 (dist 大概在 0 ~ 1.3 之间变化)
                    const dist = Math.sqrt(this.originX*this.originX + this.originY*this.originY);
                    
                    // --- 核心修改：红色渐变逻辑 (HSLA) ---
                    
                    // 1. 色相 (Hue): 固定在 355 (绯红色/深红)
                    const h = 355; 
                    
                    // 2. 饱和度 (Saturation): 高饱和度
                    const s = 95;
                    
                    // 3. 亮度 (Lightness): 
                    // 中心极亮 (75%) -> 边缘深暗 (30%左右)
                    // dist 越大，离中心越远，亮度越低
                    const l = 75 - (dist * 35);

                    // 4. 透明度 (Alpha): 随机闪烁
                    const a = Math.random() * 0.5 + 0.5;

                    this.color = `hsla(${h}, ${s}%, ${l}%, ${a})`;
                }

                updateTarget() {
                    // 拒绝采样法（保持不变）
                    let x, y;
                    let safeGuard = 0;
                    do {
                        x = Math.random() * 3 - 1.5;
                        y = Math.random() * 3 - 1.5;
                        safeGuard++;
                        if (safeGuard > 500) break; 
                    } while (!isInsideHeart(x, y));

                    this.originX = x;
                    this.originY = y;

                    this.targetX = x * heartRadius + width / 2;
                    this.targetY = -(y - 0.3) * heartRadius + height / 2; 
                }

                update(tick) {
                    const beat = Math.sin(tick * 0.05) * 0.08 + 1;
                    const curTargetX = (this.targetX - width / 2) * beat + width / 2;
                    const curTargetY = (this.targetY - height / 2) * beat + height / 2;

                    this.x += (curTargetX - this.x) * this.speed;
                    this.y += (curTargetY - this.y) * this.speed;

                    this.x += (Math.random() - 0.5) * 0.6;
                    this.y += (Math.random() - 0.5) * 0.6;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }

            let tick = 0;
            function animate() {
                // 背景拖尾色稍微调红一点点，增加氛围感（可选）
                ctx.fillStyle = 'rgba(20, 0, 0, 0.12)';
                ctx.fillRect(0, 0, width, height);

                tick++;
                particles.forEach(p => {
                    p.update(tick);
                    p.draw();
                });

                requestAnimationFrame(animate);
            }

            animate();
        }, 100);
    </script>
</body>
</html>